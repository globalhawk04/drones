# FILE: app/services/isaac_service.py
import os
import math
import numpy as np
from pxr import Usd, UsdGeom, UsdPhysics, UsdShade, Sdf, Gf, Vt

# Path where OpenSCAD saves STLs
ASSETS_DIR = os.path.abspath("output") # Changed to match cad_service output
USD_EXPORT_DIR = os.path.abspath("usd_export")
os.makedirs(USD_EXPORT_DIR, exist_ok=True)

class IsaacService:
    def __init__(self):
        pass

    def generate_robot_usd(self, robot_data):
        sku = robot_data.get('sku_id', 'robot_dog')
        stage_path = os.path.join(USD_EXPORT_DIR, f"{sku}.usda")
        
        # 1. Create New Stage
        if os.path.exists(stage_path): os.remove(stage_path)
        stage = Usd.Stage.CreateNew(stage_path)
        UsdGeom.SetStageUpAxis(stage, UsdGeom.Tokens.z) 
        UsdGeom.SetStageMetersPerUnit(stage, 1.0) 

        # 2. Define Root Xform (The Robot)
        root_path = f"/World/{sku.replace('-', '_')}"
        root_prim = UsdGeom.Xform.Define(stage, root_path)
        
        # CRITICAL: Apply Articulation Root API
        # This tells Isaac Sim "Treat everything below this as a system of joints"
        UsdPhysics.ArticulationRootAPI.Apply(root_prim.GetPrim())

        # 3. Assemble the Tree
        # Unlike drones, order matters. Parent -> Joint -> Child
        
        # --- A. CHASSIS (ROOT LINK) ---
        chassis_path = f"{root_path}/Chassis"
        self._add_link(stage, chassis_path, "Chassis_Kit", mass_kg=1.5, scale=1.0)
        
        # Get dimensions for joint placement (extracted from CAD metadata or heuristics)
        # We assume standard "Spot-Micro" geometry if specific offsets aren't provided
        body_l = 0.24 # meters
        body_w = 0.12
        hip_offset_x = body_l / 2.0
        hip_offset_y = body_w / 2.0
        
        # Leg Configuration: FR, FL, RR, RL
        legs = [
            {"name": "FR", "x": 1, "y": -1},
            {"name": "FL", "x": 1, "y": 1},
            {"name": "RR", "x": -1, "y": -1},
            {"name": "RL", "x": -1, "y": 1}
        ]

        for leg in legs:
            prefix = leg["name"]
            
            # --- B. HIP JOINT (Abduction/Adduction) ---
            # Connects Chassis -> Hip Module
            # In this simple model, we skip a separate "Hip" mesh and go straight to Femur rotation
            # but for realism, we usually have a small shoulder link. Let's assume Femur connects directly to Chassis for V1.
            
            femur_path = f"{chassis_path}/Femur_{prefix}"
            
            # Position relative to Chassis center
            hip_pos = Gf.Vec3f(leg['x'] * hip_offset_x, leg['y'] * hip_offset_y, 0)
            
            self._add_link(stage, femur_path, "Femur_Leg", mass_kg=0.2, pos=hip_pos)
            
            # Define The Joint (Revolute)
            self._add_revolute_joint(
                stage, 
                parent_path=chassis_path, 
                child_path=femur_path, 
                joint_name=f"Joint_Hip_{prefix}",
                axis="y", # Rotates around Y axis (swing forward/back)
                limit=(-45, 45),
                stiffness=10000.0 # High stiffness = Strong Servo
            )

            # --- C. KNEE JOINT (Flexion/Extension) ---
            # Connects Femur -> Tibia
            tibia_path = f"{femur_path}/Tibia_{prefix}"
            
            femur_len = 0.1 # 100mm default
            knee_pos = Gf.Vec3f(femur_len, 0, 0) # End of Femur
            
            self._add_link(stage, tibia_path, "Tibia_Leg", mass_kg=0.15, pos=knee_pos)
            
            self._add_revolute_joint(
                stage,
                parent_path=femur_path,
                child_path=tibia_path,
                joint_name=f"Joint_Knee_{prefix}",
                axis="y",
                limit=(-120, 0), # Knees bend backwards usually
                stiffness=10000.0
            )

        # 4. Save
        stage.GetRootLayer().Save()
        print(f"   ⚡ Generated Articulated USD: {stage_path}")
        return stage_path

    def _add_link(self, stage, path, stl_key, mass_kg, pos=Gf.Vec3f(0,0,0), scale=1.0):
        """Adds a Rigid Body Mesh (Link)."""
        # Define Xform
        xform = UsdGeom.Xform.Define(stage, path)
        xform.AddTranslateOp().Set(pos)
        
        # Add Physics
        rigid_api = UsdPhysics.RigidBodyAPI.Apply(xform.GetPrim())
        rigid_api.CreateRigidBodyEnabledAttr(True)
        
        mass_api = UsdPhysics.MassAPI.Apply(xform.GetPrim())
        mass_api.CreateMassAttr(mass_kg)
        
        # Add Visual Mesh (Reference STL)
        mesh_path = f"{path}/Visual"
        mesh = UsdGeom.Mesh.Define(stage, mesh_path)
        
        # Logic to find the specific STL file generated by CAD service
        # In a real run, we'd pass the specific filename map
        stl_filename = f"robot_dog_{stl_key.lower()}.stl" # simplified mapping
        stl_abs_path = os.path.join(ASSETS_DIR, stl_filename)
        
        if os.path.exists(stl_abs_path):
            mesh.GetPrim().GetReferences().AddReference(stl_abs_path)
        else:
            # Fallback Cube if CAD failed
            print(f"      ⚠️ Missing STL: {stl_filename}, using Cube.")
            cube = UsdGeom.Cube.Define(stage, mesh_path)
            cube.CreateSizeAttr(0.05)

    def _add_revolute_joint(self, stage, parent_path, child_path, joint_name, axis, limit, stiffness):
        """Creates a Physics Joint representing a Servo."""
        joint_path = f"{child_path}/{joint_name}"
        joint = UsdPhysics.RevoluteJoint.Define(stage, joint_path)
        
        # Relationships
        joint.CreateBody0Rel().AddTarget(parent_path)
        joint.CreateBody1Rel().AddTarget(child_path)
        
        # Frame 0 (Parent) - Local Transform
        # For simplicity, we assume joint is at origin of child
        joint.CreateLocalPos0Attr().Set(Gf.Vec3f(0,0,0)) 
        joint.CreateLocalRot0Attr().Set(Gf.Quatf(1,0,0,0))
        
        # Frame 1 (Child)
        joint.CreateLocalPos1Attr().Set(Gf.Vec3f(0,0,0))
        joint.CreateLocalRot1Attr().Set(Gf.Quatf(1,0,0,0))
        
        # Axis
        joint.CreateAxisAttr(axis)
        
        # Limits (The mechanical stop of the servo)
        joint.CreateLowerLimitAttr(limit[0])
        joint.CreateUpperLimitAttr(limit[1])
        
        # Drive API (The "Servo" behavior)
        # Without this, it's a floppy hinge. With this, it holds position.
        driveAPI = UsdPhysics.DriveAPI.Apply(joint.GetPrim(), "angular")
        driveAPI.CreateTypeAttr("force") # Force control mode
        driveAPI.CreateStiffnessAttr(stiffness) # P-gain
        driveAPI.CreateDampingAttr(stiffness / 10.0) # D-gain
        driveAPI.CreateTargetPositionAttr(0.0) # Initial pose